{"source_files":[{"coverage":[null,null,null,null,1,null,null],"name":"lib/crypto_trader_web/controllers/page_controller.ex","source":"defmodule CryptoTraderWeb.PageController do\n  use CryptoTraderWeb, :controller\n\n  def index(conn, _params) do\n    render(conn, \"index.html\")\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,4,null,null,null,null,2,null,null,null,0,0,0,null,null,null,null,null,0,0,null,0,0,0,null,null,null,null,null,null,1,null,null,null,null,null,2,null,1,1,null,null,1,1,null,null,null,null,2,null,2,null,null,0,null,null,null,null,2,null,null,null,null,0,null,null,null,0,0,null,0,null,null,null,0,0,null,null,null,null,0,null,null,null,null,0,0,null,null,null,null,0,null,null,null],"name":"lib/crypto_trader_web/live/live_chart.ex","source":"defmodule CryptoTraderWeb.LiveChart do\n  use Phoenix.LiveView\n\n\n\n\n  @spec mount(any, any, Phoenix.LiveView.Socket.t()) :: {:ok, Phoenix.LiveView.Socket.t()}\n  def mount(_params, _session, socket) do\n\n    if connected?(socket), do: Process.send_after(self(), :update, 5_000)\n    {:ok, socket}\n  end\n\n  def handle_params(params, _uri, socket) do\n    handle_coin_link(params, socket)\n  end\n\n  def handle_info(:update, socket) do\n    Process.send_after(self(), :update, 5_000)\n    current_pid = Map.get(socket, :current_pid)\n    chart_data = get_and_format_chart_data(current_pid)\n\n    {:noreply, push_event(socket, \"element-updated\", chart_data)}\n  end\n\n  def handle_event(\"inc_coin_change\", %{\"value\" => symbol}, socket) do\n    current_pid = Map.get(socket, :current_pid)\n    current_symbol = Map.get(socket, :current_symbol)\n\n    if symbol != current_symbol do\n      GenServer.stop(current_pid, :normal)\n      handle_params(%{current_coin: symbol}, \"/live-chart\", socket)\n    else\n      {:noreply, socket}\n    end\n  end\n\n  def render(assigns) do\n    Phoenix.View.render(CryptoTraderWeb.PageView, \"live_chart.html\", assigns)\n  end\n\n\n\n  defp handle_coin_link(params, socket) do\n    case params do\n      %{current_coin: coin_symbol} ->\n        socket = Map.put(socket, :current_symbol, coin_symbol)\n        start_link(%{coin: coin_symbol}, socket)\n\n      %{} ->\n        socket = Map.put(socket, :current_symbol, \"BTCUSD\")\n        start_link(%{coin: \"BTCUSD\"}, socket)\n    end\n  end\n\n  defp start_link(params, socket) do\n    case Binance.Client.start_link(params) do\n      {:ok, pid} ->\n        create_reply(socket, pid)\n\n      {:error, {:already_started, pid}} ->\n        create_reply(socket, pid)\n    end\n  end\n\n  defp create_reply(socket, pid) do\n    socket = socket |> Map.put(:current_pid, pid)\n    {:noreply, assign(socket, :data, Jason.encode!(%{}))}\n  end\n\n  defp get_and_format_chart_data(pid) do\n    data =\n      GenServer.call(pid, :get)\n      |> Map.get(:current_price)\n\n    price_list = create_price_list(data)\n    time_list = create_time_list(data)\n\n    %{labels: time_list, data: price_list}\n  end\n\n  defp create_price_list(data) do\n    case data do\n      nil ->\n        nil\n\n      list ->\n        list\n        |> Enum.map(fn current_map -> Map.get(current_map, \"price\") end)\n    end\n  end\n\n  defp create_time_list(data) do\n    case data do\n      nil ->\n        nil\n\n      list ->\n        list\n        |> Enum.map(fn current_map -> Map.get(current_map, \"time\") end)\n    end\n  end\nend"},{"coverage":[null,null,null,null,1,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,1,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/crypto_trader_web/router.ex","source":"defmodule CryptoTraderWeb.Router do\n  use CryptoTraderWeb, :router\n  import Phoenix.LiveView.Router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_live_flash\n    plug :put_root_layout, {CryptoTraderWeb.LayoutView, :root}\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n    # plug Plug.Static, \"apps/crypto_trader_web/assets\"\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", CryptoTraderWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :index\n    live \"/live-chart\", LiveChart\n  end\n\n  # Other scopes may use custom stacks.\n  # scope \"/api\", CryptoTraderWeb do\n  #   pipe_through :api\n  # end\n\n  # Enables LiveDashboard only for development\n  #\n  # If you want to use the LiveDashboard in production, you should put\n  # it behind authentication and allow only admins to access it.\n  # If your application does not have an admins-only section yet,\n  # you can use Plug.BasicAuth to set up some basic authentication\n  # as long as you are also using SSL (which you should anyway).\n  if Mix.env() in [:dev, :test] do\n    import Phoenix.LiveDashboard.Router\n\n    scope \"/\" do\n      pipe_through :browser\n\n      live_dashboard \"/dashboard\", metrics: CryptoTraderWeb.Telemetry\n    end\n  end\n\n  # Enables the Swoosh mailbox preview in development.\n  #\n  # Note that preview only shows emails that were sent by the same\n  # node running the Phoenix server.\n  if Mix.env() == :dev do\n    scope \"/dev\" do\n      pipe_through :browser\n\n      forward \"/mailbox\", Plug.Swoosh.MailboxPreview\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/crypto_trader_web/views/error_view.ex","source":"defmodule CryptoTraderWeb.ErrorView do\n  use CryptoTraderWeb, :view\n\n  # If you want to customize a particular status code\n  # for a certain format, you may uncomment below.\n  # def render(\"500.html\", _assigns) do\n  #   \"Internal Server Error\"\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def template_not_found(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend"}]}